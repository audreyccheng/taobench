"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[574],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(a),m=r,b=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return a?n.createElement(b,o(o({ref:t},d),{},{components:a})):n.createElement(b,o({ref:t},d))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},2872:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const i={},o="Contributing to TAOBench",s={unversionedId:"usage/drivers/contributing",id:"usage/drivers/contributing",title:"Contributing to TAOBench",description:"Adding a New Adapter Layer",source:"@site/docs/usage/drivers/contributing.md",sourceDirName:"usage/drivers",slug:"/usage/drivers/contributing",permalink:"/docs/usage/drivers/contributing",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"usageSidebar",previous:{title:"Adapter Layers",permalink:"/docs/usage/drivers/"},next:{title:"CockroachDB (Postgres)",permalink:"/docs/usage/drivers/cockroachdb"}},l={},c=[{value:"Adding a New Adapter Layer",id:"adding-a-new-adapter-layer",level:3},{value:"1) Create adapter directory",id:"1-create-adapter-directory",level:3},{value:"2) Create derived class",id:"2-create-derived-class",level:3},{value:"3) Register your class",id:"3-register-your-class",level:3}],d={toc:c};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"contributing-to-taobench"},"Contributing to TAOBench"),(0,r.kt)("h3",{id:"adding-a-new-adapter-layer"},"Adding a New Adapter Layer"),(0,r.kt)("p",null,"TAOBench uses a database interface layer to translate requests using TAO\u2019s API to database-specific requests. To add support for a new database, you should implement this interface layer (",(0,r.kt)("inlineCode",{parentName:"p"},"benchmark::DB"),") for the database. Take a look at the directories ",(0,r.kt)("inlineCode",{parentName:"p"},"crdb"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"mysqldb"),", etc. for examples."),(0,r.kt)("p",null,"TAO\u2019s API:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"read(key)"),": Read a record"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"read_txn(keys)"),": Read a group of records atomically"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"write(key,[preconditions])"),": Write to a record, optionally with a set of\npreconditions"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"write_txn(keys,[preconditions])"),": Write to a group of records atomically,\noptionally with a set of preconditions")),(0,r.kt)("h3",{id:"1-create-adapter-directory"},"1) Create adapter directory"),(0,r.kt)("p",null,"Put new adapters in separate directories. New source files should be added to ",(0,r.kt)("inlineCode",{parentName:"p"},"CMakeLists.txt"),", and since adapter layers are compiled with the benchmark executable, they should be built conditional on a CMake option."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"option(WITH_CRDB OFF)\n# ...\nif(WITH_CRDB)\n  include_directories(crdb)\n  target_sources(benchmark PRIVATE\n    crdb/crdb_db.h\n    crdb/crdb_db.cc)\n  target_link_libraries(benchmark -lpqxx)\n  target_link_libraries(benchmark -lpq)\nendif()\n")),(0,r.kt)("h3",{id:"2-create-derived-class"},"2) Create derived class"),(0,r.kt)("p",null,"Create a class that extends the ",(0,r.kt)("inlineCode",{parentName:"p"},"benchmark::DB")," class. The file ",(0,r.kt)("inlineCode",{parentName:"p"},"src/db.h"),"\ncontains this class, with descriptions of the methods that must be implemented.\nBroadly, there are three functionalities to be implemented: (a) connection\nhandling, (b) batch insert + read, and (c) queries/transactions."),(0,r.kt)("p",null,"For (a), implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Init()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Cleanup()")," methods. These manage the state\nof each client thread, e.g. connection handling. You may want to define some\nproperties in order to pass connection details; properties can be accessed from\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"props_")," variable."),(0,r.kt)("p",null,"Methods for (b) are needed to support batch inserts during the load phase and\nbatch reads that execute at the beginning of the run phase."),(0,r.kt)("p",null,"Most of the work will be done in (c), which involves point queries and\ntransactions. A few pointers:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The benchmark assumes that an ",(0,r.kt)("inlineCode",{parentName:"li"},"objects")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"edges")," table has already been\ncreated. The database interface must support queries to both tables (the\n",(0,r.kt)("inlineCode",{parentName:"li"},"DB_Operation")," passed to each method indicates which table should be\naccessed)."),(0,r.kt)("li",{parentName:"ul"},"There are four types of edges: ",(0,r.kt)("inlineCode",{parentName:"li"},"unique"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"bidirectional"),",\n",(0,r.kt)("inlineCode",{parentName:"li"},"unique_and_bidirectional"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"other"),". During edge inserts, requests to the\ndatabase should respect the semantics of these edge types. Uniqueness means\nthat only one id2 can exist for each id1. Bidirectionality determines whether\nthe inverse exists or not.")),(0,r.kt)("p",null,"Here's a cut-down version of the ",(0,r.kt)("inlineCode",{parentName:"p"},"DB")," class:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Database interface layer"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"///\n/// Database interface layer.\n/// per-thread DB instance.\n///\nclass DB {\n  // ...\n\n  /// Initializes any state for accessing this DB.\n  virtual void Init() { }\n\n  /// Clears any state for accessing this DB.\n  virtual void Cleanup() { }\n\n  /// Reads a record from the database.\n  virtual Status Read(DataTable table, const std::vector<Field> & key,\n                      std::vector<TimestampValue> &buffer) = 0;\n\n  /// Updates a record in @param table for @param key with @param value\n  virtual Status Update(DataTable table, const std::vector<Field> &key,\n                        TimestampValue const & value) = 0;\n\n  /// Inserts a record in @param table for @param key with @param value.\n  virtual Status Insert(DataTable table, const std::vector<Field> &key,\n                        TimestampValue const & value) = 0;\n\n  /// Deletes a record from the database.\n  virtual Status Delete(DataTable table, const std::vector<Field> &key,\n                        TimestampValue const & value) = 0;\n\n  /// Execute a single operation (READ, INSERT, UPDATE, DELETE)\n  virtual Status Execute(const DB_Operation &operation,\n                         std::vector<TimestampValue> &read_buffer, // for reads\n                         bool txn_op = false) = 0;\n\n  /// @param operations vector of operations to be completed as one transaction\n  virtual Status ExecuteTransaction(const std::vector<DB_Operation> &operations,\n                                    std::vector<TimestampValue> &read_buffer,\n                                    bool read_only) = 0;\n\n  /// Insert records in @param table for @param keys with @param values\n  virtual Status BatchInsert(DataTable table, const std::vector<std::vector<Field>> &keys,\n                             std::vector<TimestampValue> const & values) = 0;\n\n  /// This method reads the first @n keys (or all of them, whichever is smaller) from @param table\n  /// in the OPEN interval (@param floor_key, @param ceiling_key) and writes them to @param key_buffer\n  /// in sorted order.\n  virtual Status BatchRead(DataTable table, const std::vector<Field> &floor_key,\n                           const std::vector<Field> &ceiling_key,\n                           int n, std::vector<std::vector<Field>> &key_buffer) = 0;\n\n  /// ...\n};\n"))),(0,r.kt)("h3",{id:"3-register-your-class"},"3) Register your class"),(0,r.kt)("p",null,"Finally, ensure that the benchmark is aware of your newly created database\ninterface. This can be done by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"DBFactory::RegisterDB")," and assigning its\nreturn value to a global constant in your adapter's source file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'DB *NewExampleDB() { return new ExampleDB; }\n\nconst bool registered = DBFactory::RegisterDB("exampledb", NewExampleDB);\n')))}p.isMDXComponent=!0}}]);