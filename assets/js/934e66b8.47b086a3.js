"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7574],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>m});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),d=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(r),m=a,b=u["".concat(s,".").concat(m)]||u[m]||p[m]||i;return r?n.createElement(b,o(o({ref:t},c),{},{components:r})):n.createElement(b,o({ref:t},c))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var d=2;d<i;d++)o[d]=r[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},2872:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var n=r(7462),a=(r(7294),r(3905));const i={},o="Contributing to TAOBench",l={unversionedId:"usage/drivers/contributing",id:"usage/drivers/contributing",title:"Contributing to TAOBench",description:"Adding a New Adapter Layer",source:"@site/docs/usage/drivers/contributing.md",sourceDirName:"usage/drivers",slug:"/usage/drivers/contributing",permalink:"/docs/usage/drivers/contributing",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"usageSidebar",previous:{title:"Adapter Layers",permalink:"/docs/usage/drivers/"},next:{title:"CockroachDB (Postgres)",permalink:"/docs/usage/drivers/cockroachdb"}},s={},d=[{value:"Adding a New Adapter Layer",id:"adding-a-new-adapter-layer",level:3},{value:"1) Create adapter directory",id:"1-create-adapter-directory",level:3},{value:"2) Create derived class",id:"2-create-derived-class",level:3},{value:"3) Register your class",id:"3-register-your-class",level:3}],c={toc:d};function p(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"contributing-to-taobench"},"Contributing to TAOBench"),(0,a.kt)("h3",{id:"adding-a-new-adapter-layer"},"Adding a New Adapter Layer"),(0,a.kt)("p",null,"TAOBench uses a database interface layer to translate requests using TAO\u2019s API to database-specific requests. To add support for a new database, you should implement this interface layer (",(0,a.kt)("inlineCode",{parentName:"p"},"benchmark::DB"),") for the database. Take a look at the directories ",(0,a.kt)("inlineCode",{parentName:"p"},"crdb"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"mysqldb"),", etc. for examples."),(0,a.kt)("p",null,"TAO\u2019s API:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"read(key)"),": Read a record"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"read_txn(keys)"),": Read a group of records atomically"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"write(key,[preconditions])"),": Write to a record, optionally with a set of\npreconditions"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"write_txn(keys,[preconditions])"),": Write to a group of records atomically,\noptionally with a set of preconditions")),(0,a.kt)("h3",{id:"1-create-adapter-directory"},"1) Create adapter directory"),(0,a.kt)("p",null,"Put new adapters in separate directories. New source files should be added to ",(0,a.kt)("inlineCode",{parentName:"p"},"CMakeLists.txt"),", and since adapter layers are compiled with the benchmark executable, they should be built conditional on a CMake option."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"option(WITH_CRDB OFF)\n# ...\nif(WITH_CRDB)\n  include_directories(crdb)\n  target_sources(benchmark PRIVATE\n    crdb/crdb_db.h\n    crdb/crdb_db.cc)\n  target_link_libraries(benchmark -lpqxx)\n  target_link_libraries(benchmark -lpq)\nendif()\n")),(0,a.kt)("h3",{id:"2-create-derived-class"},"2) Create derived class"),(0,a.kt)("p",null,"Create a class that extends the ",(0,a.kt)("inlineCode",{parentName:"p"},"benchmark::DB")," class. The file ",(0,a.kt)("inlineCode",{parentName:"p"},"src/db.h")," contains this class, with descriptions of the methods that must be implemented. Broadly, there are three functionalities to be implemented: (1) connection handling, (2) batch insert + read, and (3) queries/transactions."),(0,a.kt)("p",null,"For (1), implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"Init()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Cleanup()")," methods. You may want to define some properties in order to pass connection details; properties will be loaded into the ",(0,a.kt)("inlineCode",{parentName:"p"},"props_")," variable."),(0,a.kt)("p",null,"Most of the work will be done in (3). A few pointers:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The benchmark assumes that an ",(0,a.kt)("inlineCode",{parentName:"li"},"objects")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"edges")," table has already been created. The database interface must support queries to both tables (the ",(0,a.kt)("inlineCode",{parentName:"li"},"DB_Operation")," passed to each method indicates which table should be accessed)."),(0,a.kt)("li",{parentName:"ul"},"There are four types of edges: ",(0,a.kt)("inlineCode",{parentName:"li"},"unique"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"bidirectional"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"unique_and_bidirectional"),", and ",(0,a.kt)("inlineCode",{parentName:"li"},"other"),". During edge inserts, requests to the database should respect the semantics of these edge types. Uniqueness means that only one id2 can exist for each id1. Bidirectionality determines whether the inverse exists or not.")),(0,a.kt)("h3",{id:"3-register-your-class"},"3) Register your class"),(0,a.kt)("p",null,"Finally, ensure that the benchmark is aware of your newly created database interface:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'DB *NewExampleDB() { return new ExampleDB; }\n\nconst bool registered = DBFactory::RegisterDB("exampledb", NewExampleDB);\n')))}p.isMDXComponent=!0}}]);